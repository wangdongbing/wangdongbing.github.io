<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">




















  
  
  <link rel="stylesheet" href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5">







<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.0.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.0.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.0.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.0.1">


  <link rel="mask-icon" href="/images/logo.svg?v=7.0.1" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '7.0.1',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: true,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="AQS全称AbstractQueuedSynchronized，意思为抽象队列同步器，在JDK的并发中，AQS占据着举足轻重的位置，许多常用的同步组件都依赖于它，AQS定义了一套线程之间资源访问同步的框架和机制，上层的同步组件比如ReentrantLock/Semaphore/CountDownLatch等只要实现AQS定义的方法和模版，对于其底层的详细实现，AQS会帮我们处理，接下来我们分析一下">
<meta name="keywords" content="AQS,并发,jdk">
<meta property="og:type" content="article">
<meta property="og:title" content="AQS介绍">
<meta property="og:url" content="http://www.wangdongbing.com/2020/06/18/java/AQS原理分析/index.html">
<meta property="og:site_name" content="好好学习,天天向上">
<meta property="og:description" content="AQS全称AbstractQueuedSynchronized，意思为抽象队列同步器，在JDK的并发中，AQS占据着举足轻重的位置，许多常用的同步组件都依赖于它，AQS定义了一套线程之间资源访问同步的框架和机制，上层的同步组件比如ReentrantLock/Semaphore/CountDownLatch等只要实现AQS定义的方法和模版，对于其底层的详细实现，AQS会帮我们处理，接下来我们分析一下">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2020-06-18T15:01:41.201Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="AQS介绍">
<meta name="twitter:description" content="AQS全称AbstractQueuedSynchronized，意思为抽象队列同步器，在JDK的并发中，AQS占据着举足轻重的位置，许多常用的同步组件都依赖于它，AQS定义了一套线程之间资源访问同步的框架和机制，上层的同步组件比如ReentrantLock/Semaphore/CountDownLatch等只要实现AQS定义的方法和模版，对于其底层的详细实现，AQS会帮我们处理，接下来我们分析一下">






  <link rel="canonical" href="http://www.wangdongbing.com/2020/06/18/java/AQS原理分析/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>AQS介绍 | 好好学习,天天向上</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">好好学习,天天向上</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.wangdongbing.com/2020/06/18/java/AQS原理分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="WDB">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="好好学习,天天向上">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">AQS介绍

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-06-18 16:43:20 / 修改时间：23:01:41" itemprop="dateCreated datePublished" datetime="2020-06-18T16:43:20+08:00">2020-06-18</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/JDK/" itemprop="url" rel="index"><span itemprop="name">JDK</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>AQS全称AbstractQueuedSynchronized，意思为抽象队列同步器，在JDK的并发中，AQS占据着举足轻重的位置，许多常用的同步组件都依赖于它，AQS定义了一套线程之间资源访问同步的框架和机制，上层的同步组件比如ReentrantLock/Semaphore/CountDownLatch等只要实现AQS定义的方法和模版，对于其底层的详细实现，AQS会帮我们处理，接下来我们分析一下AQS中的主要组件以及代码原理</p>
<h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><p>AQS维护了一个volatile int state（代表共享资源）和一个FIFO线程等待队列（多线程争用资源被阻塞时会进入此队列）。这里volatile是核心关键词，具体volatile的语义，在此不述。state的访问方式有三种:<br>getState()<br>setState()<br>compareAndSetState()</p>
<p>AQS定义两种资源共享方式：Exclusive（独占，只有一个线程能执行，如ReentrantLock）和Share（共享，多个线程可同时执行，如Semaphore/CountDownLatch）。</p>
<p>不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源state的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS已经在顶层实现好了。自定义同步器实现时主要实现以下几种方法：<br>isHeldExclusively()：该线程是否正在独占资源。只有用到condition才需要去实现它。<br>tryAcquire(int)：独占方式。尝试获取资源，成功则返回true，失败则返回false。<br>tryRelease(int)：独占方式。尝试释放资源，成功则返回true，失败则返回false。<br>tryAcquireShared(int)：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。<br>tryReleaseShared(int)：共享方式。尝试释放资源，成功则返回true，失败则返回false。<br>　　以ReentrantLock为例，state初始化为0，表示未锁定状态。A线程lock()时，会调用tryAcquire()独占该锁并将state+1。此后，其他线程再tryAcquire()时就会失败，直到A线程unlock()到state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的。<br>　　再以CountDownLatch以例，任务分为N个子线程去执行，state也初始化为N（注意N要与线程个数一致）。这N个子线程是并行执行的，每个子线程执行完后countDown()一次，state会CAS减1。等到所有子线程都执行完后(即state=0)，会unpark()主调用线程，然后主调用线程就会从await()函数返回，继续后余动作。<br>　　一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared中的一种即可。但AQS也支持自定义同步器同时实现独占和共享两种方式，如ReentrantReadWriteLock。<br>三、源码详解<br>　　本节开始讲解AQS的源码实现。依照acquire-release、acquireShared-releaseShared的次序来。<br>3.1 acquire(int)<br>　　此方法是独占模式下线程获取共享资源的顶层入口。如果获取到资源，线程直接返回，否则进入等待队列，直到获取到资源为止，且整个过程忽略中断的影响。这也正是lock()的语义，当然不仅仅只限于lock()。获取到资源后，线程就可以去执行其临界区代码了。下面是acquire()的源码：<br>1 public final void acquire(int arg) {<br>2     if (!tryAcquire(arg) &amp;&amp;<br>3         acquireQueued(addWaiter(Node.EXCLUSIVE), arg))<br>4         selfInterrupt();<br>5 }</p>
<p>　　函数流程如下：<br>tryAcquire()尝试直接去获取资源，如果成功则直接返回；<br>addWaiter()将该线程加入等待队列的尾部，并标记为独占模式；<br>acquireQueued()使线程在等待队列中获取资源，一直获取到资源后才返回。如果在整个等待过程中被中断过，则返回true，否则返回false。<br>如果线程在等待过程中被中断过，它是不响应的。只是获取资源后才再进行自我中断selfInterrupt()，将中断补上。<br>　　这时单凭这4个抽象的函数来看流程还有点朦胧，不要紧，看完接下来的分析后，你就会明白了。就像《大话西游》里唐僧说的：等你明白了舍生取义的道理，你自然会回来和我唱这首歌的。<br>3.1.1 tryAcquire(int)<br>　　此方法尝试去获取独占资源。如果获取成功，则直接返回true，否则直接返回false。这也正是tryLock()的语义，还是那句话，当然不仅仅只限于tryLock()。如下是tryAcquire()的源码：<br>1     protected boolean tryAcquire(int arg) {<br>2         throw new UnsupportedOperationException();<br>3     }</p>
<p>　　什么？直接throw异常？说好的功能呢？好吧，还记得概述里讲的AQS只是一个框架，具体资源的获取/释放方式交由自定义同步器去实现吗？就是这里了！！！AQS这里只定义了一个接口，具体资源的获取交由自定义同步器去实现了（通过state的get/set/CAS）！！！至于能不能重入，能不能加塞，那就看具体的自定义同步器怎么去设计了！！！当然，自定义同步器在进行资源访问时要考虑线程安全的影响。<br>　　这里之所以没有定义成abstract，是因为独占模式下只用实现tryAcquire-tryRelease，而共享模式下只用实现tryAcquireShared-tryReleaseShared。如果都定义成abstract，那么每个模式也要去实现另一模式下的接口。说到底，Doug Lea还是站在咱们开发者的角度，尽量减少不必要的工作量。<br>3.1.2 addWaiter(Node)<br>　　此方法用于将当前线程加入到等待队列的队尾，并返回当前线程所在的结点。还是上源码吧：</p>
<p> 1 private Node addWaiter(Node mode) {<br> 2     //以给定模式构造结点。mode有两种：EXCLUSIVE（独占）和SHARED（共享）<br> 3     Node node = new Node(Thread.currentThread(), mode);<br> 4<br> 5     //尝试快速方式直接放到队尾。<br> 6     Node pred = tail;<br> 7     if (pred != null) {<br> 8         node.prev = pred;<br> 9         if (compareAndSetTail(pred, node)) {<br>10             pred.next = node;<br>11             return node;<br>12         }<br>13     }<br>14<br>15     //上一步失败则通过enq入队。<br>16     enq(node);<br>17     return node;<br>18 }</p>
<p> 不用再说了，直接看注释吧。<br>3.1.2.1 enq(Node)<br> 　　此方法用于将node加入队尾。源码如下：</p>
<p> 1 private Node enq(final Node node) {<br> 2     //CAS”自旋”，直到成功加入队尾<br> 3     for (;;) {<br> 4         Node t = tail;<br> 5         if (t == null) { // 队列为空，创建一个空的标志结点作为head结点，并将tail也指向它。<br> 6             if (compareAndSetHead(new Node()))<br> 7                 tail = head;<br> 8         } else {//正常流程，放入队尾<br> 9             node.prev = t;<br>10             if (compareAndSetTail(t, node)) {<br>11                 t.next = node;<br>12                 return t;<br>13             }<br>14         }<br>15     }<br>16 }</p>
<p>如果你看过AtomicInteger.getAndIncrement()函数源码，那么相信你一眼便看出这段代码的精华。CAS自旋volatile变量，是一种很经典的用法。还不太了解的，自己去百度一下吧。<br>3.1.3 acquireQueued(Node, int)<br>　　OK，通过tryAcquire()和addWaiter()，该线程获取资源失败，已经被放入等待队列尾部了。聪明的你立刻应该能想到该线程下一部该干什么了吧：进入等待状态休息，直到其他线程彻底释放资源后唤醒自己，自己再拿到资源，然后就可以去干自己想干的事了。没错，就是这样！是不是跟医院排队拿号有点相似~~acquireQueued()就是干这件事：在等待队列中排队拿号（中间没其它事干可以休息），直到拿到号后再返回。这个函数非常关键，还是上源码吧：</p>
<p> 1 final boolean acquireQueued(final Node node, int arg) {<br> 2     boolean failed = true;//标记是否成功拿到资源<br> 3     try {<br> 4         boolean interrupted = false;//标记等待过程中是否被中断过<br> 5<br> 6         //又是一个“自旋”！<br> 7         for (;;) {<br> 8             final Node p = node.predecessor();//拿到前驱<br> 9             //如果前驱是head，即该结点已成老二，那么便有资格去尝试获取资源（可能是老大释放完资源唤醒自己的，当然也可能被interrupt了）。<br>10             if (p == head &amp;&amp; tryAcquire(arg)) {<br>11                 setHead(node);//拿到资源后，将head指向该结点。所以head所指的标杆结点，就是当前获取到资源的那个结点或null。<br>12                 p.next = null; // setHead中node.prev已置为null，此处再将head.next置为null，就是为了方便GC回收以前的head结点。也就意味着之前拿完资源的结点出队了！<br>13                 failed = false;<br>14                 return interrupted;//返回等待过程中是否被中断过<br>15             }<br>16<br>17             //如果自己可以休息了，就进入waiting状态，直到被unpark()<br>18             if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>19                 parkAndCheckInterrupt())<br>20                 interrupted = true;//如果等待过程中被中断过，哪怕只有那么一次，就将interrupted标记为true<br>21         }<br>22     } finally {<br>23         if (failed)<br>24             cancelAcquire(node);<br>25     }<br>26 }</p>
<p>到这里了，我们先不急着总结acquireQueued()的函数流程，先看看shouldParkAfterFailedAcquire()和parkAndCheckInterrupt()具体干些什么。<br>3.1.3.1 shouldParkAfterFailedAcquire(Node, Node)<br>　　此方法主要用于检查状态，看看自己是否真的可以去休息了（进入waiting状态，如果线程状态转换不熟，可以参考本人上一篇写的Thread详解），万一队列前边的线程都放弃了只是瞎站着，那也说不定，对吧！</p>
<p> 1 private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {<br> 2     int ws = pred.waitStatus;//拿到前驱的状态<br> 3     if (ws == Node.SIGNAL)<br> 4         //如果已经告诉前驱拿完号后通知自己一下，那就可以安心休息了<br> 5         return true;<br> 6     if (ws &gt; 0) {<br> 7         /<em><br> 8          </em> 如果前驱放弃了，那就一直往前找，直到找到最近一个正常等待的状态，并排在它的后边。<br> 9          <em> 注意：那些放弃的结点，由于被自己“加塞”到它们前边，它们相当于形成一个无引用链，稍后就会被保安大叔赶走了(GC回收)！<br>10          </em>/<br>11         do {<br>12             node.prev = pred = pred.prev;<br>13         } while (pred.waitStatus &gt; 0);<br>14         pred.next = node;<br>15     } else {<br>16          //如果前驱正常，那就把前驱的状态设置成SIGNAL，告诉它拿完号后通知自己一下。有可能失败，人家说不定刚刚释放完呢！<br>17         compareAndSetWaitStatus(pred, ws, Node.SIGNAL);<br>18     }<br>19     return false;<br>20 }</p>
<p>整个流程中，如果前驱结点的状态不是SIGNAL，那么自己就不能安心去休息，需要去找个安心的休息点，同时可以再尝试下看有没有机会轮到自己拿号。<br>3.1.3.2 parkAndCheckInterrupt()<br>　　如果线程找好安全休息点后，那就可以安心去休息了。此方法就是让线程去休息，真正进入等待状态。<br>1 private final boolean parkAndCheckInterrupt() {<br>2     LockSupport.park(this);//调用park()使线程进入waiting状态<br>3     return Thread.interrupted();//如果被唤醒，查看自己是不是被中断的。<br>4 }<br> 　　park()会让当前线程进入waiting状态。在此状态下，有两种途径可以唤醒该线程：1）被unpark()；2）被interrupt()。（再说一句，如果线程状态转换不熟，可以参考本人写的Thread详解）。需要注意的是，Thread.interrupted()会清除当前线程的中断标记位。<br>3.1.3.3 小结<br>　　OK，看了shouldParkAfterFailedAcquire()和parkAndCheckInterrupt()，现在让我们再回到acquireQueued()，总结下该函数的具体流程：<br>结点进入队尾后，检查状态，找到安全休息点；<br>调用park()进入waiting状态，等待unpark()或interrupt()唤醒自己；<br>被唤醒后，看自己是不是有资格能拿到号。如果拿到，head指向当前结点，并返回从入队到拿到号的整个过程中是否被中断过；如果没拿到，继续流程1。</p>
<p>3.1.4 小结<br>　　OKOK，acquireQueued()分析完之后，我们接下来再回到acquire()！再贴上它的源码吧：<br>1 public final void acquire(int arg) {<br>2     if (!tryAcquire(arg) &amp;&amp;<br>3         acquireQueued(addWaiter(Node.EXCLUSIVE), arg))<br>4         selfInterrupt();<br>5 }<br>再来总结下它的流程吧：<br>调用自定义同步器的tryAcquire()尝试直接去获取资源，如果成功则直接返回；<br>没成功，则addWaiter()将该线程加入等待队列的尾部，并标记为独占模式；<br>acquireQueued()使线程在等待队列中休息，有机会时（轮到自己，会被unpark()）会去尝试获取资源。获取到资源后才返回。如果在整个等待过程中被中断过，则返回true，否则返回false。<br>如果线程在等待过程中被中断过，它是不响应的。只是获取资源后才再进行自我中断selfInterrupt()，将中断补上。<br>由于此函数是重中之重，我再用流程图总结一下：</p>
<p>至此，acquire()的流程终于算是告一段落了。这也就是ReentrantLock.lock()的流程，不信你去看其lock()源码吧，整个函数就是一条acquire(1)！！！</p>
<p>3.2 release(int)<br> 　　上一小节已经把acquire()说完了，这一小节就来讲讲它的反操作release()吧。此方法是独占模式下线程释放共享资源的顶层入口。它会释放指定量的资源，如果彻底释放了（即state=0）,它会唤醒等待队列里的其他线程来获取资源。这也正是unlock()的语义，当然不仅仅只限于unlock()。下面是release()的源码：</p>
<p>1 public final boolean release(int arg) {<br>2     if (tryRelease(arg)) {<br>3         Node h = head;//找到头结点<br>4         if (h != null &amp;&amp; h.waitStatus != 0)<br>5             unparkSuccessor(h);//唤醒等待队列里的下一个线程<br>6         return true;<br>7     }<br>8     return false;<br>9 }</p>
<p>　　逻辑并不复杂。它调用tryRelease()来释放资源。有一点需要注意的是，它是根据tryRelease()的返回值来判断该线程是否已经完成释放掉资源了！所以自定义同步器在设计tryRelease()的时候要明确这一点！！<br>3.2.1 tryRelease(int)<br>　　此方法尝试去释放指定量的资源。下面是tryRelease()的源码：<br>1 protected boolean tryRelease(int arg) {<br>2     throw new UnsupportedOperationException();<br>3 }</p>
<p>　　跟tryAcquire()一样，这个方法是需要独占模式的自定义同步器去实现的。正常来说，tryRelease()都会成功的，因为这是独占模式，该线程来释放资源，那么它肯定已经拿到独占资源了，直接减掉相应量的资源即可(state-=arg)，也不需要考虑线程安全的问题。但要注意它的返回值，上面已经提到了，release()是根据tryRelease()的返回值来判断该线程是否已经完成释放掉资源了！所以自义定同步器在实现时，如果已经彻底释放资源(state=0)，要返回true，否则返回false。<br>3.2.2 unparkSuccessor(Node)<br>　　此方法用于唤醒等待队列中下一个线程。下面是源码：</p>
<p> 1 private void unparkSuccessor(Node node) {<br> 2     //这里，node一般为当前线程所在的结点。<br> 3     int ws = node.waitStatus;<br> 4     if (ws &lt; 0)//置零当前线程所在的结点状态，允许失败。<br> 5         compareAndSetWaitStatus(node, ws, 0);<br> 6<br> 7     Node s = node.next;//找到下一个需要唤醒的结点s<br> 8     if (s == null || s.waitStatus &gt; 0) {//如果为空或已取消<br> 9         s = null;<br>10         for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev)<br>11             if (t.waitStatus &lt;= 0)//从这里可以看出，&lt;=0的结点，都是还有效的结点。<br>12                 s = t;<br>13     }<br>14     if (s != null)<br>15         LockSupport.unpark(s.thread);//唤醒<br>16 }</p>
<p>　　这个函数并不复杂。一句话概括：用unpark()唤醒等待队列中最前边的那个未放弃线程，这里我们也用s来表示吧。此时，再和acquireQueued()联系起来，s被唤醒后，进入if (p == head &amp;&amp; tryAcquire(arg))的判断（即使p!=head也没关系，它会再进入shouldParkAfterFailedAcquire()寻找一个安全点。这里既然s已经是等待队列中最前边的那个未放弃线程了，那么通过shouldParkAfterFailedAcquire()的调整，s也必然会跑到head的next结点，下一次自旋p==head就成立啦），然后s把自己设置成head标杆结点，表示自己已经获取到资源了，acquire()也返回了！！And then, DO what you WANT!<br>3.2.3 小结<br>　　release()是独占模式下线程释放共享资源的顶层入口。它会释放指定量的资源，如果彻底释放了（即state=0）,它会唤醒等待队列里的其他线程来获取资源。<br>3.3 acquireShared(int)<br>　　此方法是共享模式下线程获取共享资源的顶层入口。它会获取指定量的资源，获取成功则直接返回，获取失败则进入等待队列，直到获取到资源为止，整个过程忽略中断。下面是acquireShared()的源码：<br>1 public final void acquireShared(int arg) {<br>2     if (tryAcquireShared(arg) &lt; 0)<br>3         doAcquireShared(arg);<br>4 }</p>
<p>　　这里tryAcquireShared()依然需要自定义同步器去实现。但是AQS已经把其返回值的语义定义好了：负值代表获取失败；0代表获取成功，但没有剩余资源；正数表示获取成功，还有剩余资源，其他线程还可以去获取。所以这里acquireShared()的流程就是：<br>tryAcquireShared()尝试获取资源，成功则直接返回；<br>失败则通过doAcquireShared()进入等待队列，直到获取到资源为止才返回。<br>3.3.1 doAcquireShared(int)<br>　　此方法用于将当前线程加入等待队列尾部休息，直到其他线程释放资源唤醒自己，自己成功拿到相应量的资源后才返回。下面是doAcquireShared()的源码：</p>
<p> 1 private void doAcquireShared(int arg) {<br> 2     final Node node = addWaiter(Node.SHARED);//加入队列尾部<br> 3     boolean failed = true;//是否成功标志<br> 4     try {<br> 5         boolean interrupted = false;//等待过程中是否被中断过的标志<br> 6         for (;;) {<br> 7             final Node p = node.predecessor();//前驱<br> 8             if (p == head) {//如果到head的下一个，因为head是拿到资源的线程，此时node被唤醒，很可能是head用完资源来唤醒自己的<br> 9                 int r = tryAcquireShared(arg);//尝试获取资源<br>10                 if (r &gt;= 0) {//成功<br>11                     setHeadAndPropagate(node, r);//将head指向自己，还有剩余资源可以再唤醒之后的线程<br>12                     p.next = null; // help GC<br>13                     if (interrupted)//如果等待过程中被打断过，此时将中断补上。<br>14                         selfInterrupt();<br>15                     failed = false;<br>16                     return;<br>17                 }<br>18             }<br>19<br>20             //判断状态，寻找安全点，进入waiting状态，等着被unpark()或interrupt()<br>21             if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>22                 parkAndCheckInterrupt())<br>23                 interrupted = true;<br>24         }<br>25     } finally {<br>26         if (failed)<br>27             cancelAcquire(node);<br>28     }<br>29 }</p>
<p>　　有木有觉得跟acquireQueued()很相似？对，其实流程并没有太大区别。只不过这里将补中断的selfInterrupt()放到doAcquireShared()里了，而独占模式是放到acquireQueued()之外，其实都一样，不知道Doug Lea是怎么想的。<br>　　跟独占模式比，还有一点需要注意的是，这里只有线程是head.next时（“老二”），才会去尝试获取资源，有剩余的话还会唤醒之后的队友。那么问题就来了，假如老大用完后释放了5个资源，而老二需要6个，老三需要1个，老四需要2个。因为老大先唤醒老二，老二一看资源不够自己用继续park()，也更不会去唤醒老三和老四了。独占模式，同一时刻只有一个线程去执行，这样做未尝不可；但共享模式下，多个线程是可以同时执行的，现在因为老二的资源需求量大，而把后面量小的老三和老四也都卡住了。</p>
<p>3.3.1.1 setHeadAndPropagate(Node, int)</p>
<p> 1 private void setHeadAndPropagate(Node node, int propagate) {<br> 2     Node h = head;<br> 3     setHead(node);//head指向自己<br> 4      //如果还有剩余量，继续唤醒下一个邻居线程<br> 5     if (propagate &gt; 0 || h == null || h.waitStatus &lt; 0) {<br> 6         Node s = node.next;<br> 7         if (s == null || s.isShared())<br> 8             doReleaseShared();<br> 9     }<br>10 }</p>
<p>　　此方法在setHead()的基础上多了一步，就是自己苏醒的同时，如果条件符合（比如还有剩余资源），还会去唤醒后继结点，毕竟是共享模式！<br>　　doReleaseShared()我们留着下一小节的releaseShared()里来讲。</p>
<p>3.3.2 小结<br>　　OK，至此，acquireShared()也要告一段落了。让我们再梳理一下它的流程：<br>tryAcquireShared()尝试获取资源，成功则直接返回；<br>失败则通过doAcquireShared()进入等待队列park()，直到被unpark()/interrupt()并成功获取到资源才返回。整个等待过程也是忽略中断的。<br>　　其实跟acquire()的流程大同小异，只不过多了个自己拿到资源后，还会去唤醒后继队友的操作（这才是共享嘛）。<br>3.4 releaseShared()<br>　　上一小节已经把acquireShared()说完了，这一小节就来讲讲它的反操作releaseShared()吧。此方法是共享模式下线程释放共享资源的顶层入口。它会释放指定量的资源，如果彻底释放了（即state=0）,它会唤醒等待队列里的其他线程来获取资源。下面是releaseShared()的源码：</p>
<p>1 public final boolean releaseShared(int arg) {<br>2     if (tryReleaseShared(arg)) {//尝试释放资源<br>3         doReleaseShared();//唤醒后继结点<br>4         return true;<br>5     }<br>6     return false;<br>7 }</p>
<p>　　此方法的流程也比较简单，一句话：释放掉资源后，唤醒后继。跟独占模式下的release()相似，但有一点稍微需要注意：独占模式下的tryRelease()在完全释放掉资源（state=0）后，才会返回true去唤醒其他线程，这主要是基于可重入的考量；而共享模式下的releaseShared()则没有这种要求，一是共享的实质–多线程可并发执行；二是共享模式基本也不会重入吧（至少我还没见过），所以自定义同步器可以根据需要决定返回值。<br>3.4.1 doReleaseShared()<br>　　此方法主要用于唤醒后继。下面是它的源码：</p>
<p> 1 private void doReleaseShared() {<br> 2     for (;;) {<br> 3         Node h = head;<br> 4         if (h != null &amp;&amp; h != tail) {<br> 5             int ws = h.waitStatus;<br> 6             if (ws == Node.SIGNAL) {<br> 7                 if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))<br> 8                     continue;<br> 9                 unparkSuccessor(h);//唤醒后继<br>10             }<br>11             else if (ws == 0 &amp;&amp;<br>12                      !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))<br>13                 continue;<br>14         }<br>15         if (h == head)// head发生变化<br>16             break;<br>17     }<br>18 }</p>
<p>3.5 小结<br>　　本节我们详解了独占和共享两种模式下获取-释放资源(acquire-release、acquireShared-releaseShared)的源码，相信大家都有一定认识了。值得注意的是，acquire()和acquireSahred()两种方法下，线程在等待队列中都是忽略中断的。AQS也支持响应中断的，acquireInterruptibly()/acquireSharedInterruptibly()即是，这里相应的源码跟acquire()和acquireSahred()差不多，这里就不再详解了。</p>
<p>四、简单应用<br>　　通过前边几个章节的学习，相信大家已经基本理解AQS的原理了。这里再将“框架”一节中的一段话复制过来：<br>　　不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源state的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS已经在顶层实现好了。自定义同步器实现时主要实现以下几种方法：<br>isHeldExclusively()：该线程是否正在独占资源。只有用到condition才需要去实现它。<br>tryAcquire(int)：独占方式。尝试获取资源，成功则返回true，失败则返回false。<br>tryRelease(int)：独占方式。尝试释放资源，成功则返回true，失败则返回false。<br>tryAcquireShared(int)：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。<br>tryReleaseShared(int)：共享方式。尝试释放资源，成功则返回true，失败则返回false。<br>　　OK，下面我们就以AQS源码里的Mutex为例，讲一下AQS的简单应用。<br>4.1 Mutex（互斥锁）<br>　　Mutex是一个不可重入的互斥锁实现。锁资源（AQS里的state）只有两种状态：0表示未锁定，1表示锁定。下边是Mutex的核心源码：</p>
<p> 1 class Mutex implements Lock, java.io.Serializable {<br> 2     // 自定义同步器<br> 3     private static class Sync extends AbstractQueuedSynchronizer {<br> 4         // 判断是否锁定状态<br> 5         protected boolean isHeldExclusively() {<br> 6             return getState() == 1;<br> 7         }<br> 8<br> 9         // 尝试获取资源，立即返回。成功则返回true，否则false。<br>10         public boolean tryAcquire(int acquires) {<br>11             assert acquires == 1; // 这里限定只能为1个量<br>12             if (compareAndSetState(0, 1)) {//state为0才设置为1，不可重入！<br>13                 setExclusiveOwnerThread(Thread.currentThread());//设置为当前线程独占资源<br>14                 return true;<br>15             }<br>16             return false;<br>17         }<br>18<br>19         // 尝试释放资源，立即返回。成功则为true，否则false。<br>20         protected boolean tryRelease(int releases) {<br>21             assert releases == 1; // 限定为1个量<br>22             if (getState() == 0)//既然来释放，那肯定就是已占有状态了。只是为了保险，多层判断！<br>23                 throw new IllegalMonitorStateException();<br>24             setExclusiveOwnerThread(null);<br>25             setState(0);//释放资源，放弃占有状态<br>26             return true;<br>27         }<br>28     }<br>29<br>30     // 真正同步类的实现都依赖继承于AQS的自定义同步器！<br>31     private final Sync sync = new Sync();<br>32<br>33     //lock<-->acquire。两者语义一样：获取资源，即便等待，直到成功才返回。<br>34     public void lock() {<br>35         sync.acquire(1);<br>36     }<br>37<br>38     //tryLock<-->tryAcquire。两者语义一样：尝试获取资源，要求立即返回。成功则为true，失败则为false。<br>39     public boolean tryLock() {<br>40         return sync.tryAcquire(1);<br>41     }<br>42<br>43     //unlock<-->release。两者语文一样：释放资源。<br>44     public void unlock() {<br>45         sync.release(1);<br>46     }<br>47<br>48     //锁是否占有状态<br>49     public boolean isLocked() {<br>50         return sync.isHeldExclusively();<br>51     }<br>52 }</--></--></--></p>
<p>　　同步类在实现时一般都将自定义同步器（sync）定义为内部类，供自己使用；而同步类自己（Mutex）则实现某个接口，对外服务。当然，接口的实现要直接依赖sync，它们在语义上也存在某种对应关系！！而sync只用实现资源state的获取-释放方式tryAcquire-tryRelelase，至于线程的排队、等待、唤醒等，上层的AQS都已经实现好了，我们不用关心。<br>　　除了Mutex，ReentrantLock/CountDownLatch/Semphore这些同步类的实现方式都差不多，不同的地方就在获取-释放资源的方式tryAcquire-tryRelelase。掌握了这点，AQS的核心便被攻破了！<br>　　OK，至此，整个AQS的讲解也要落下帷幕了。希望本文能够对学习Java并发编程的同学有所借鉴，中间写的有不对的地方，也欢迎讨论和指正~</p>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/AQS/" rel="tag"># AQS</a>
          
            <a href="/tags/并发/" rel="tag"># 并发</a>
          
            <a href="/tags/jdk/" rel="tag"># jdk</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/06/18/一致性Hash介绍/" rel="next" title="一致性hash介绍">
                <i class="fa fa-chevron-left"></i> 一致性hash介绍
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">WDB</p>
              <div class="site-description motion-element" itemprop="description"></div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">25</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">12</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">40</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#框架"><span class="nav-number">1.</span> <span class="nav-text">框架</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">WDB</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.0.1</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>












  















  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script src="/js/src/utils.js?v=7.0.1"></script>

  <script src="/js/src/motion.js?v=7.0.1"></script>



  
  


  <script src="/js/src/schemes/muse.js?v=7.0.1"></script>



  
  <script src="/js/src/scrollspy.js?v=7.0.1"></script>
<script src="/js/src/post-details.js?v=7.0.1"></script>



  


  <script src="/js/src/next-boot.js?v=7.0.1"></script>


  

  


  


  




  

  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
